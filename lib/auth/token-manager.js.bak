/*
 * This Source Code Form is subject to the terms of the
 * Mozilla Public License, v. 2.0. If a copy of the MPL
 * was not distributed with this file, You can obtain
 * one at http://mozilla.org/MPL/2.0/.
 */

/*
 * Copyright 2019 Joyent, Inc.
 * Copyright 2025 Edgecast Cloud LLC.
 */

/*
 * token-manager.js: Authentication token creation and
 * parsing.
 *
 * Handles encryption/decryption of authentication tokens
 * using AES-128-CBC with gzip compression.
 */

var crypto = require('crypto');
var zlib = require('zlib');

var assert = require('assert-plus');

var constants = require('../constants');
require('../errors');


///--- Globals

var TOKEN_ALG = 'aes-128-cbc';
var TOKEN_ENC = 'base64';


///--- Internal Functions

/**
 * Creates an encrypted authentication token from
 * caller and context information.
 *
 * @param {Object} opts - options object
 * @param {Object} opts.caller - authenticated caller
 * @param {Object} opts.context - auth context
 * @param {Boolean} opts.fromjob - token from job
 * @param {Object} aes - AES encryption config
 * @param {String} aes.key - hex-encoded AES key
 * @param {String} aes.iv - hex-encoded IV
 * @param {Function} cb - callback(err, token)
 */
function createAuthToken(opts, aes, cb) {
    assert.object(opts, 'opts');
    assert.object(opts.caller, 'opts.caller');
    assert.optionalObject(opts.context, 'opts.context');
    assert.optionalBool(opts.fromjob, 'opts.fromjob');
    assert.object(aes, 'aes');
    assert.string(aes.key, 'aes.key');
    assert.string(aes.iv, 'aes.iv');
    assert.func(cb, 'callback');

    var cipher;
    var principal = {};
    var conditions = {};
    var caller = opts.caller;
    var context = opts.context;

    // Safe buffer creation for Node.js v0.10.48
    if (aes.key.length > 128 || aes.iv.length > 64) {
        return (cb(new Error(
            'Crypto key or IV too long')));
    }

    cipher = crypto.createCipheriv(TOKEN_ALG,
        new Buffer(aes.key, 'hex'),
        new Buffer(aes.iv, 'hex'));
    assert.ok(cipher, 'failed to create crypto cipher');

    // Build principal object
    if (caller.account) {
        principal.account = {
            uuid: caller.account.uuid,
            login: caller.account.login,
            groups: caller.account.groups || [],
            approved_for_provisioning:
                caller.account.approved_for_provisioning
        };
    }

    if (caller.user) {
        principal.user = {
            uuid: caller.user.uuid
        };
    }

    // Build conditions object
    if (context) {
        conditions = context;
    }
    if (opts.fromjob !== undefined) {
        conditions.fromjob = opts.fromjob;
    }

    var payload = JSON.stringify({
        t: Date.now(),
        p: principal,
        c: conditions,
        v: 2
    });

    // Validate size before compression
    if (payload.length >
        constants.SIZE_LIMITS.COMPRESSION_MAX) {
        return (cb(new Error(
            'String too large for compression')));
    }

    zlib.gzip(new Buffer(payload, 'utf8'),
        function (err, buf) {
        if (err) {
            cb(err);
            return;
        }

        var token = cipher.update(buf, 'binary',
            'base64');
        token += cipher.final('base64');
        cb(null, token);
    });
}


/**
 * Parses and validates an encrypted authentication
 * token.
 *
 * @param {String} token - base64 encoded token
 * @param {Object} aes - AES decryption config
 * @param {String} aes.salt - hex-encoded salt
 * @param {String} aes.key - hex-encoded AES key
 * @param {String} aes.iv - hex-encoded IV
 * @param {Number} aes.maxAge - max token age in ms
 * @param {Function} cb - callback(err, obj)
 */
function parseAuthToken(token, aes, cb) {
    assert.string(token, 'token');
    assert.object(aes, 'aes');
    assert.string(aes.salt, 'aes.salt');
    assert.string(aes.key, 'aes.key');
    assert.string(aes.iv, 'aes.iv');
    assert.number(aes.maxAge, 'aes.maxAge');
    assert.func(cb, 'callback');

    var decipher;
    var buf;

    // Safe buffer creation
    if (aes.key.length > 128 || aes.iv.length > 64) {
        return (cb(new Error(
            'Crypto key or IV too long')));
    }

    decipher = crypto.createDecipheriv(TOKEN_ALG,
        new Buffer(aes.key, 'hex'),
        new Buffer(aes.iv, 'hex'));
    assert.ok(decipher,
        'failed to create crypto decipher');

    try {
        buf = decipher.update(token, 'base64',
            'binary');
        buf += decipher.final('binary');
    } catch (_e) {
        setImmediate(function () {
            cb(new InvalidAuthTokenError());
        });
        return;
    }

    zlib.gunzip(new Buffer(buf, 'binary'),
        function (err, str) {
        if (err) {
            cb(new InvalidAuthTokenError());
            return;
        }

        var cracked;
        try {
            cracked = JSON.parse(str) || {};
        } catch (_e) {
            cb(new InvalidAuthTokenError());
            return;
        }

        // Validate token version
        if (cracked.v !== 1 && cracked.v !== 2) {
            cb(new InvalidAuthTokenError(
                'an invalid version'));
            return;
        }

        // Check token age
        if ((Date.now() - cracked.t) > aes.maxAge) {
            cb(new InvalidAuthTokenError('expired'));
            return;
        }

        var obj;
        if (cracked.v === 1) {
            // Legacy token format
            obj = {
                caller: {
                    roles: {},
                    account: {
                        uuid: cracked.u,
                        login: cracked.l,
                        groups: cracked.g,
                        approved_for_provisioning: true,
                        isOperator: cracked.g.some(
                            function (e) {
                            return (e === 'operators');
                        })
                    }
                },
                ctime: cracked.t
            };
        } else {
            // Current token format (v2)
            obj = {
                principal: cracked.p,
                conditions: cracked.c,
                ctime: cracked.t
            };
        }

        cb(null, obj);
    });
}


///--- Restify Handlers

/**
 * Restify handler to create authentication token
 */
function createAuthTokenHandler(req, res, next) {
    var aes = req.config.authToken;
    var caller = req.caller;
    var context = req.authContext;
    var log = req.log;

    var opts = {
        caller: caller,
        context: context,
        fromjob: false
    };

    log.debug(opts, 'createAuthToken: entered');
    createAuthToken(opts, aes, function (err, token) {
        if (err) {
            log.error(err,
                'unable to create auth token');
            next(new InternalError());
            return;
        }

        // HAProxy has 8k limit on header size
        if (Buffer.byteLength(token) > 8192) {
            log.error({token: token},
                'createAuthToken: token too big');
            next(new InternalError());
            return;
        }

        log.debug({token: token},
            'createAuthToken: done');
        res.send(201, {token: token});
        next();
    });
}


/**
 * Restify handler to parse authentication token
 */
function parseAuthTokenHandler(req, res, next) {
    var log = req.log;
    var token = req.auth.token;

    if (!token) {
        next();
        return;
    }

    var aes = req.config.authToken;
    log.debug('parseAuthTokenHandler: entered');

    parseAuthToken(token, aes, function (err, obj) {
        if (err) {
            log.debug(err,
                'parseAuthTokenHandler: failed');
            next(err);
            return;
        }

        req.auth.token = obj;
        log.debug('parseAuthTokenHandler: done');
        next();
    });
}


///--- Exports

module.exports = {
    create: createAuthToken,
    parse: parseAuthToken,
    createHandler: createAuthTokenHandler,
    parseHandler: parseAuthTokenHandler
};
